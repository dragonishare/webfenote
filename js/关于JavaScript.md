# JavaScript历史

## 历史
Brendan Eich只用10天时间就把Javascript设计出来了。

由于设计时间太短，语言的一些细节考虑得不够严谨，导致后来很长一段时间，JavaScript写出来的程序混乱不堪。

总的来说，他的设计思路是这样的：

1. 借鉴C语言的基本语法；
2. 借鉴Java语言的数据类型和内存管理；
3. 借鉴Scheme语言，将函数提升到"第一等公民"（first class）的地位；
4. 借鉴Self语言，使用基于原型（prototype）的继承机制。

所以，**JavaScript语言实际上是两种语言风格的混合产物----（简化的）函数式编程+（简化的）面向对象编程**。这是由Brendan Eich（函数式编程）与网景公司（面向对象编程）共同决定的。

如果不是公司的决策，Brendan Eich绝不可能把Java作为Javascript设计的原型。作为设计者，他一点也不喜欢自己的这个作品：
> "与其说我爱Javascript，不如说我恨它。它是C语言和Self语言一夜情的产物。十八世纪英国文学家约翰逊博士说得好：'它的优秀之处并非原创，它的原创之处并不优秀。'（the part that is good is not original, and the part that is original is not good.）"

## 为什么JavaScript有设计缺陷

* 设计阶段过于仓促

 > JavaScript的设计时间短，只用了十天。这种语言的设计初衷，是为了解决一些简单的网页互动（比如，检查"用户名"是否填写），并没有考虑复杂应用的需要。

* 没有先例

 > JavaScript同时结合了**函数式编程和面向对象编程**的特点，这很可能是历史上的第一例。而且直到今天为止，JavaScript仍然是世界上唯一使用**Prototype继承模型**的主要语言。这使得它没有设计先例可以参考。
 
* 过早的标准化

 > JavaScript的发展非常快，根本没有时间调整设计。
1995年5月，设计方案定稿；10月，解释器开发成功；12月，向市场推出，立刻被广泛接受，全世界的用户大量使用。JavaScript缺乏一个从小到大、慢慢积累用户的过程，而是连续的爆炸式扩散增长。大量的既成网页和业余网页设计者的参与，使得调整语言规格困难重重。
更糟的是，JavaScript的规格还没来及调整，就固化了。
1996年8月，微软公司强势介入，宣布推出自己的脚本语言Jscript；11月，为了压制微软，网景公司决定申请JavaScript的国际标准；1997年6月，第一个国际标准ECMA-262正式颁布。
也就是说，JavaScript推出一年半之后，国际标准就问世了。设计缺陷还没有充分暴露就成了标准。相比之下，C语言问世将近20年之后，国际标准才颁布。

### JavaScript的10个设计缺陷
* 不适合开发大型程序   

JavaScript没有名称空间（namespace），很难模块化；没有如何将代码分布在多个文件的规范；允许同名函数的重复定义，后面的定义可以覆盖前面的定义，很不利于模块化加载。

* 非常小的标准库

JavaScript提供的标准函数库非常小，只能完成一些基本操作，很多功能都不具备。

* null和undefined

在编程实践中，null几乎没用，根本不应该设计它。

* 全局变量难以控制

JavaScript的全局变量，在所有模块中都是可见的；任何一个函数内部都可以生成全局变量，这大大加剧了程序的复杂性。

* 自动插入行尾分号

JavaScript的所有语句，都必须以分号结尾。但是，如果你忘记加分号，解释器并不报错，而是为你自动加上分号。有时候，这会导致一些难以发现的错误。

* 加号运算符

+号作为运算符，有两个含义，可以表示数字与数字的和，也可以表示字符与字符的连接。
如果一个操作项是字符，另一个操作项是数字，则数字自动转化为字符。
这样的设计，不必要地加剧了运算的复杂性，完全可以另行设置一个字符连接的运算符。

* NaN

NaN是一种数字，表示超出了解释器的极限。它有一些很奇怪的特性：
```
　　NaN === NaN; //false
　　NaN !== NaN; //true
　　alert( 1 + NaN ); // NaN
```
与其设计NaN，不如解释器直接报错，反而有利于简化程序。

* 数组和对象的区分

由于JavaScript的数组也属于对象（object），所以要区分一个对象到底是不是数组，相当麻烦。
```
if ( arr && typeof arr === 'object' && typeof arr.length === 'number' && !arr.propertyIsEnumerable('length')){
　　　　alert("arr is an array");
　　}
```

* == 和 ===

==用来判断两个值是否相等。当两个值类型不同时，会发生自动转换，得到的结果非常不符合直觉。
```
    "" == "0" // false
　　0 == "" // true
　　0 == "0" // true
　　false == "false" // false
　　false == "0" // true
　　false == undefined // false
　　false == null // false
　　null == undefined // true
　　" \t\r\n" == 0 // true
```
因此，推荐任何时候都使用"==="（精确判断）比较符。

* 基本类型的包装对象

JavaScript有三种基本数据类型：字符串、数字和布尔值。它们都有相应的建构函数，可以生成字符串对象、数字对象和布尔值对象。

### 继承
JavaScript里面都是对象，必须有一种机制，将所有对象联系起来。所以，Brendan Eich最后还是设计了"继承"。

但是，他不打算引入"类"（class）的概念，因为一旦有了"类"，JavaScript就是一种完整的面向对象编程语言了，这好像有点太正式了，而且增加了初学者的入门难度。
他考虑到，C++和Java语言都使用new命令，生成实例。
因此，他就把**new**命令引入了JavaScript，用来从原型对象生成一个实例对象。但是，JavaScript没有"类"，怎么来表示原型对象呢？
这时，他想到C++和Java使用new命令时，都会调用"类"的**构造函数（constructor）**。他就做了一个简化的设计，在JavaScript语言中，new命令后面跟的不是类，而是构造函数。

用构造函数生成实例对象，有一个缺点，那就是**无法共享属性和方法**。每一个实例对象，都有自己的属性和方法的副本。这不仅无法做到数据共享，也是极大的资源浪费。

Brendan Eich决定为构造函数设置一个**prototype**属性。

这个属性包含一个对象（以下简称"prototype对象"），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。
实例对象一旦创建，将自动引用prototype对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，**一种是本地的，另一种是引用的**。

由于所有的实例对象共享同一个prototype对象，那么从外界看起来，prototype对象就好像是实例对象的原型，而实例对象则好像"继承"了prototype对象一样。

这就是**JavaScript继承机制**的设计思想。



## 参考资料

* [Javascript继承机制的设计思想](http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html)
* [Javascript诞生记](http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html)

